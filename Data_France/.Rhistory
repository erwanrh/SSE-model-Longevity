}
else if(is.complex(x)) {
y <- Im(x)
x <- Re(x)
}
else if(is.matrix(x) && ncol(x) == 2) {
y <- x[, 2]
x <- x[, 1]
}
else {
y <- x
x <- time(x)
}
}
## about the offset
m <- length(y)
if(missing(offset)) {
offset <- rep(0, m)
}else{
if(length(offset) == 1) {
offset <- rep(offset, m)
}
else{
offset=offset
}
}
check <- Mort1Dsmooth_checker(x=x, y=y,
offset=offset, w=w,
overdispersion=overdispersion,
ndx=ndx, deg=deg,
pord=pord,
lambda=lambda, df=df,
method=method,
coefstart=coefstart,
control=control)
x <- check$x
y <- check$y
m <- check$m
offset <- check$offset
offsetINIT <- check$offsetINIT
wei <- check$w
over <- check$overdispersion
ndx <- check$ndx
deg <- check$deg
pord <- check$pord
lambda <- check$lambda
df <- check$df
MET <- check$method
a.init <- check$coefstart
MON <- check$control$MON
TOL1 <- check$control$TOL1
TOL2 <- check$control$TOL2
RANGE <- check$control$RANGE
MAX.IT <- check$control$MAX.IT
call <- match.call()
## B-splines basis
xl <- min(x)
xr <- max(x)
xmax <- xr + 0.01 * (xr - xl)
xmin <- xl - 0.01 * (xr - xl)
B <- MortSmooth_bbase(x, xmin, xmax, ndx, deg)
## penalty stuff
nb <- ncol(B)
D. <- diff(diag(nb), diff=pord)
DtD <- t(D.)%*%D.
## General initialize:
if(is.null(a.init)){
y[is.na(y)] <- 0
## 0) simple poisson-GLM with ages(years)
##    only for the interpolation cases
fit0 <- glm(round(y) ~ x + offset(offset),
family=poisson, weights=wei)
## 1) simple penalized-poisson-GLM with B
etaGLM <- log(fit0$fitted) - offset
eta0 <- log((y + 1)) - offset
eta0[wei==0] <- etaGLM[wei==0]
mu0 <- exp(offset + eta0)
w0 <- wei*mu0
z0 <- wei*((y - mu0)/mu0 + eta0)
BtWB <- t(B) %*% (w0 * B)
BtWz <- t(B) %*% (w0 * z0)
a.init <- solve(BtWB + 1e08 * DtD, BtWz)
}else{
a.init=a.init
}
psi2 <- 1
## ## plotting starting coef
## ran <- range(log(y/e), B%*%a.init,
##              na.rm=TRUE, finite = TRUE)
## plot(x, log(y/e), ylim=ran)
## lines(x, B%*%a.init, col=2, lwd=2)
## optimize AIC or BIC
if(MET==1|MET==2){
## if overdisperion is true
if(over){
tol.over <- 10
i.over <- 0
while(tol.over > 1e-03 && i.over < 5){
i.over <- i.over+1
lambda.hat <- Mort1Dsmooth_optimize(x=x,
y=y,
offset=offset,
wei=wei,
psi2=psi2,
B=B, DtD=DtD,
a.init=a.init,
MON=MON,
TOL1=TOL1,
TOL2=TOL2,
RANGE=RANGE,
MAX.IT=MAX.IT,
MET=MET)
FIT <- Mort1Dsmooth_estimate(x=x, y=y,
offset=offset,
wei=wei,
psi2=psi2,
B=B,
lambda=lambda.hat,
DtD=DtD,
a.init=a.init,
MON=MON, TOL1=TOL1,
MAX.IT=MAX.IT)
## recalculating overdispersion parameter
psi2.old <- psi2
psi2 <- FIT$dev / (m - FIT$df)
tol.over <- abs(psi2 - psi2.old)/abs(psi2)
}
}else{## if psi2==1
lambda.hat <- Mort1Dsmooth_optimize(x=x,
y=y,
offset=offset,
wei=wei,
psi2=psi2,
B=B, DtD=DtD,
a.init=a.init,
MON=MON,
TOL1=TOL1,
TOL2=TOL2,
RANGE=RANGE,
MAX.IT=MAX.IT,
MET=MET)
FIT <- Mort1Dsmooth_estimate(x=x, y=y, offset=offset,
wei=wei,
psi2=psi2,
B=B,
lambda=lambda.hat,
DtD=DtD,
a.init=a.init,
MON=MON, TOL1=TOL1,
MAX.IT=MAX.IT)
psi2 <- FIT$dev / (m - FIT$df)
}
if(log10(lambda.hat)>=log10(RANGE[2]) |
log10(lambda.hat)<=log10(RANGE[1])) {
warning(paste("optimal lambda at the edge of the grid."))
}
}
## given lambda
if(MET==3){
lambda.hat <- lambda
FIT <- Mort1Dsmooth_estimate(x=x, y=y, offset=offset,
wei=wei,
psi2=psi2,
B=B,
lambda=lambda.hat, DtD=DtD,
a.init=a.init,
MON=MON, TOL1=TOL1,
MAX.IT=MAX.IT)
psi2 <- FIT$dev / (m - FIT$df)
}
## optimize given df
if(MET==4){
Mort1Dsmooth_opt_df <- function(X){
FIT <- Mort1Dsmooth_estimate(x=x, y=y, offset=offset,
wei=wei,
psi2=psi2,
B=B,
lambda=X, DtD=DtD,
a.init=a.init,
MON=MON, TOL1=TOL1,
MAX.IT=MAX.IT)
return(abs(FIT$df - df))
}
by.lambda <- length(seq(log10(RANGE[1]),
log10(RANGE[2]),by=TOL2))
lambda.hat <- cleversearch(fn=Mort1Dsmooth_opt_df,
lower=log10(RANGE[1]),
upper=log10(RANGE[2]),
ngrid=by.lambda,
startvalue=1,
logscale=TRUE,
verbose=FALSE)[[1]]
if(log10(lambda.hat)>=log10(RANGE[2]) |
log10(lambda.hat)<=log10(RANGE[1])){
warning(paste("optimal lambda at the edge of the grid."))
}
FIT <- Mort1Dsmooth_estimate(x=x, y=y, offset=offset,
wei=wei,
psi2=psi2,
B=B,
lambda=lambda.hat,
DtD=DtD,
a.init=a.init,
MON=MON, TOL1=TOL1,
MAX.IT=MAX.IT)
psi2 <- FIT$dev / (m - FIT$df)
}
aic <- FIT$aic
bic <- FIT$bic
df <- FIT$df
dev <- FIT$dev
coef <- FIT$a
psi2 <- psi2
h <- FIT$h
tolerance <- FIT$tol
eta.hat <- B%*%coef
logmortality <- eta.hat
fitted.values <- exp(eta.hat + offset)
res <- sign(y - fitted.values) *
sqrt(2 * (y * log(ifelse(y == 0, 1,
y/fitted.values)) -
(y - fitted.values)))
lin <- as.vector(eta.hat) + as.vector(offset)
## output
object <- list(## fitted values
coefficients=as.vector(coef),
residuals=as.vector(res),
fitted.values=as.vector(fitted.values),
linear.predictors=lin,
logmortality=logmortality,
## diagnostics
lev=h, df=df, deviance=dev,
aic=aic, bic=bic,
psi2=psi2, lambda=lambda.hat,
## general
call=call, n=m, tolerance=tolerance,
## smoothing specifications
ndx=ndx, deg=deg, pord=pord, B=B,
## overdispersion=over,
## observed values
x=x, y=as.vector(y),
offset=as.vector(offsetINIT),
w=as.vector(wei)
)
class(object) <- "Mort1Dsmooth"
object
}
Mort1Dsmooth_checker <-
function(x, y, offset, w,
overdispersion,
ndx, deg, pord,
lambda, df, method,
coefstart,
control){
## Input:
## x: abcissae of data
## y: count response
## offset: an a priori known component (optional)
## w: weights
## overdispersion: logical on the presence of
##                  overdispersion
## ndx: number of internal knots -1.
##      Default: floor(length(x)/5)
## deg: degree of the B-splines. Default: 3
## pord: order of differences. Default: 2
## lambda: smoothing parameter. Default: NULL (optional)
## df: a number which specifies the degrees of freedom.
##     Default: NULL (optional)
## method: the method for controlling the amount of
##         smoothing. Default: 4
## coefstart: eventual initial coefficients
## control: a list of control parameters
## Output: a list containing CHECKED arguments
##         for the Mort1Dsmooth function
m <- length(y)
offsetINIT <- offset
## about infinitive or NA offset
whioff <- which(is.infinite(offset) | is.na(offset))
whiwei <- which(w==0)
if(any(!whioff%in%whiwei)){
stop("weights different from zero associated with infinitive or NA offset values")
}
offset[c(whioff, whiwei)] <- 100
## about lengths and wrong values
if (length(x)!=length(y))
stop("Arguments must have same length")
if (length(y) != m | length(offset) != m)
stop("Argument arrays of wrong length")
if (deg < 1 | deg >= 10)
stop("Wrong value for deg")
if (pord <= 0 | pord >= 5)
stop("Wrong value for pord")
if (ndx < 2 | ndx >= floor(m*.9))
stop("Wrong value for ndx")
coefstart.check <- is.null(coefstart)
if(!coefstart.check){
if(length(coefstart)!=(ndx+deg)){
stop("coefstart must have length equal to ndx+deg")
}
}
## about method
if (method != 1 & method != 2 &
method != 3 & method != 4)
stop("Wrong value for method")
## method = 1 adjusts lambda so that the BIC is minimized
## method = 2 adjusts lambda so that the AIC is minimized
## method = 3 uses the value supplied for lambda
## method = 4 adjusts lambda so that the degrees of
##          freedom is equal to df
## check-point methods
lambda.check <- is.null(lambda)
df.check <- is.null(df)
MET <- NULL
## both lambda and df NULL
if(lambda.check & df.check & method==1){MET=1}
if(lambda.check & df.check & method==2){MET=2}
if(lambda.check & df.check & method==3){
stop("with method 3, provide lambda")
}
if(lambda.check & df.check & method==4){
stop("with method 4, provide df")
}
## lambda NULL and df GIVEN
if(lambda.check & !df.check & method==1){
stop("df and method 1 cannot be chosen together")
}
if(lambda.check & !df.check & method==2){
stop("df and method 2 cannot be chosen together")
}
if(lambda.check & !df.check & method==3){
stop("df and method 3 cannot be chosen together")
}
if(lambda.check & !df.check & method==4){MET=4}
## lambda GIVEN and df NULL
if(!lambda.check & df.check & method==1){
stop("lambda and method 1 cannot be chosen together")
}
if(!lambda.check & df.check & method==2){
stop("lambda and method 2 cannot be chosen together")
}
if(!lambda.check & df.check & method==3){MET=3}
if(!lambda.check & df.check & method==4){
stop("lambda and method 4 cannot be chosen together")
}
## both lambda and df GIVEN, regardless method
if(!lambda.check & !df.check){
stop("lambda and df cannot be chosen together")
}
## impossible values for lambda and df
if(!lambda.check && lambda<0)
stop("lambda must be positive")
if(!df.check && df<pord)
stop("df must be larger than pord")
if(!df.check && df>c(ndx+deg))
stop("df must be smaller than ndx+deg")
if (!df.check & length(df)!=1)
stop("df must be length 1")
if (!lambda.check & length(lambda)!=1)
stop("lambda must be length 1")
## setting control-parameters
con <- list(MON=FALSE, TOL1=1e-06, TOL2=0.5,
RANGE=c(10^-4, 10^6), MAX.IT=50)
nmsC <- names(con)
con[(namc <- names(control))] <- control
if (length(noNms <- namc[!namc %in% nmsC]) > 0)
warning("unknown names in control: ",
paste(noNms, collapse = ", "))
## stop about weights
if(length(w)!=m){
stop("length of w and y must be equal")
}
## warning about interpolation/extrapolation
if(any(w==0)){
warning("Interpolation and/or extrapolation is taking place", call. = FALSE)
}
## about the overdispersion parameter
if(overdispersion & method==3)
warning("given method 3, overdispersion is computed a posteriori")
if(overdispersion & method==4)
warning("given method 4, overdispersion is computed a posteriori")
## warning about weights
if(min(w) < 0) {
warning(paste("At least one weight entry is negative"))
}
## returning
llist <- list(x=x, y=y, offset=offset, w=w,
offsetINIT=offsetINIT,
overdispersion=overdispersion, m=m,
ndx=ndx, deg=deg, pord=pord,
lambda=lambda, df=df, method=method,
coefstart=coefstart,
control=con)
llist
}
plot.Mort1Dsmooth(TEST1)
install.packages("W:/399-External/_Erwan/De Antoine/MortHump_0.2.tar.gz", repos = NULL, type = "source")
install.packages("WeightedCluster")
install.packages("demog")
install.packages("demography")
install.packages("minpack.lm")
install.packages("W:/399-External/_Erwan/De Antoine/MortHump_0.2.tar.gz", repos = NULL, type = "source")
install.packages("latticeExtra")
install.packages("W:/399-External/_Erwan/De Antoine/MortHump_0.2.tar.gz", repos = NULL, type = "source")
install.packages("W:/399-External/_Erwan/De Antoine/latticeExtra_0.6-26.tar.gz", repos = NULL, type = "source")
install.packages("W:/399-External/_Erwan/De Antoine/MortHump_0.2.tar.gz", repos = NULL, type = "source")
install.packages("W:/399-External/_Erwan/De Antoine/MortHump_0.2.tar.gz", repos = NULL, type = "source")
Data <- read.csv('W:/399-External/_Erwan/Model/Morocco/Morocco_plot_data.csv',row.names=1)
DataExtra <- read.csv('W:/399-External/_Erwan/Model/Morocco/Morocco_plot_dataextra.csv',row.names=1)
ggplot(subset(Data))+ geom_line(aes(x=Age2,y=qx_male,group= Year), size=1)+ ggtitle('Mortality Rates - Morocco - Qx') + scale_y_continuous(trans='log10',labels=percent)+
facet_wrap(.~Year,scales = 'free')
ggplot(subset(DataExtra))+ geom_line(aes(x=Age2,y=qx_male,group= Year), size=1)+ ggtitle('Mortality Rates - Morocco - Qx') + scale_y_continuous(trans='log10',labels=percent)+
facet_wrap(.~Year,scales = 'free')
ggplot(subset(DataExtra))+ geom_line(aes(x=Age,y=qx_male,group= Year), size=1)+ ggtitle('Mortality Rates - Morocco - Qx') + scale_y_continuous(trans='log10',labels=percent)+
facet_wrap(.~Year,scales = 'free')
qx3<-ggplot(DataExtra)+ geom_line(aes(x=Age,y=qx_male,group= Year,color=Year), size=1)+ ggtitle('Mortality Rates - Morocco - Qx') +
scale_y_continuous(trans='log10',labels=percent) +
geom_point(aes(x=Age2,y=qx_male,group= Year,color=Year), size=1.5)
qx3<-ggplot(DataExtra)+ geom_line(aes(x=Age,y=qx_male,group= Year,color=Year), size=1)+ ggtitle('Mortality Rates - Morocco - Qx') +
qx3
qx3<-ggplot(DataExtra)+ geom_line(aes(x=Age,y=qx_male,group= Year,color=Year), size=1)+ ggtitle('Mortality Rates - Morocco - Qx') +
scale_y_continuous(trans='log10',labels=percent) +
geom_point(aes(x=Age,y=qx_male,group= Year,color=Year), size=1.5)
qx3
ggsave('W:/399-External/_Erwan/Model/qx_only_extrapolated.pdf',qx2, height = 8, width=15)
ggsave('W:/399-External/_Erwan/Model/qx_only_extrapolated.pdf',qx3, height = 8, width=15)
#GRAPHS OF ALL YEARS QX ############################
qx <- ggplot(subset(Data,Year!=2000))+ geom_line(aes(x=Age2,y=qx_male,group= Year,color=Year), size=1)+ ggtitle('Mortality Rates - Morocco - Qx') +
scale_y_continuous(trans='log10',labels=percent) +
geom_point(aes(x=Age2,y=qx_male,group= Year,color=Year), size=1.5)
#GRAPH OF ALL YEARS DEATHS
dea <- ggplot(Data)+ geom_line(aes(x=Age2,y=X1,group= Year,color=Year), size=1)+ ggtitle('Death counts - Morocco - Dx')
#GRAPH OF ALL YAERS EXPOSURES
exp <- ggplot(Data)+ geom_line(aes(x=Age2,y=Male,group= Year,color=Year), size=1)+ ggtitle('Exposure - Morocco - Ex')
#3 GRAPHS GRID
plots <- grid.arrange(dea, exp,qx)
ggsave('W:/399-External/_Erwan/Model/allplots.pdf',plots, height = 15, width=10)
seq(0,80,1)
ggplot(DataExtra)+ geom_line(aes(x=Age,y=qx_male,group= Year,color=Year), size=1)+ ggtitle('Mortality Rates - Morocco - Qx') +
scale_y_continuous(trans='log10',labels=percent) + scale_x_continuous(breaks= seq(0,80,1))
geom_point(aes(x=Age,y=qx_male,group= Year,color=Year), size=1.5)
ggplot(DataExtra)+ geom_line(aes(x=Age,y=qx_male,group= Year,color=Year), size=1)+ ggtitle('Mortality Rates - Morocco - Qx') +
scale_y_continuous(trans='log10',labels=percent) + scale_x_continuous(breaks= seq(0,80,2))
geom_point(aes(x=Age,y=qx_male,group= Year,color=Year), size=1.5)
qx3<-ggplot(DataExtra)+ geom_line(aes(x=Age,y=qx_male,group= Year,color=Year), size=1)+ ggtitle('Mortality Rates - Morocco - Qx') +
scale_y_continuous(trans='log10',labels=percent) + scale_x_continuous(breaks= seq(0,80,5))
geom_point(aes(x=Age,y=qx_male,group= Year,color=Year), size=1.5)
ggsave('W:/399-External/_Erwan/Model/qx_only_extrapolated.pdf',qx3, height = 8, width=15)
qx3<-ggplot(DataExtra)+ geom_line(aes(x=Age,y=qx_male,group= Year,color=Year), size=1)+ ggtitle('Mortality Rates - Morocco - Qx') +
scale_y_continuous(trans='log10',labels=percent) + scale_x_continuous(breaks= seq(0,80,5))
geom_point(aes(x=Age,y=qx_male,group= Year,color=Year), size=1.5)
ggsave('W:/399-External/_Erwan/Model/qx_only_extrapolated.pdf',qx3, height = 8, width=15)
qx3<-ggplot(DataExtra)+ geom_line(aes(x=Age,y=qx_male,group= Year,color=Year), size=1)+ ggtitle('Mortality Rates - Morocco - Qx') +
scale_y_continuous(trans='log10',labels=percent) + scale_x_continuous(breaks= seq(0,80,5))+
geom_point(aes(x=Age,y=qx_male,group= Year,color=Year), size=1.5)
ggsave('W:/399-External/_Erwan/Model/qx_only_extrapolated.pdf',qx3, height = 8, width=15)
View(Data2)
View(Data2_melt)
DataExtra <- read.csv('W:/399-External/_Erwan/Model/Morocco/Morocco_plot_dataextra.csv',row.names=1)
DataExtra
cast(DataExtra, Age~Year)
library(ggplot2)
library(reshape2)
library(gridExtra)
library(scales)
cast(DataExtra, Age~Year)
library(reshape2)
cast(DataExtra, Age~Year)
library(ggplot2)
library(reshape2)
library(gridExtra)
library(scales)
Data <- read.csv('W:/399-External/_Erwan/Model/Morocco/Morocco_plot_data.csv',row.names=1)
DataExtra <- read.csv('W:/399-External/_Erwan/Model/Morocco/Morocco_plot_dataextra.csv',row.names=1)
cast(DataExtra, Age~Year)
melt(data = )
dcast(DataExtra, Age~Year)
qx_mat <- as.matrix(dcast(DataExtra, Age~Year),rownames.value = NULL)
qx_mat
qx_mat <- as.matrix(dcast(DataExtra, Age~Year),rownames.value = Age)
qx_mat
qx_mat <- as.matrix(dcast(DataExtra, Age~Year),rownames.value = 'Age')
qx_mat
qx_mat <- as.matrix(dcast(DataExtra, Age~Year)[,2:6],rownames.value = 'Age')
qx_mat
colnames(qx_mat) <- as.numeric(substr(colnames(qx_mat),2,5))
qx_mat
qx_mat <- as.matrix(dcast(DataExtra, Age~Year)[,2:6],rownames.value = 'Age')
library(plotly)
p <- plot_ly(y=row.names(RR_model_mat),x=colnames(RR_model_mat),z = RR_model_mat, type = "surface") %>%
layout(
title = paste0('Morocco Qx - Male'),
scene = list( xaxis = list(title = "Year"),
yaxis = list(title = "Age"),
zaxis = list(title = "RR"))  )
row.names(qx_mat)
qx_mat <- as.matrix(dcast(DataExtra, Age~Year)[,2:6],rownames.value = NULL)
row.names(qx_mat)
DataExtra
qx_mat <- as.matrix(dcast(DataExtra, Age~Year)[,1:6],rownames.value = 1)
qx_mat
row.names(qx_mat)
qx_mat['Age']
qx_mat[,'Age']
colnames(qx_mat)
p <- plot_ly(y=qx_mat[,'Age'],x=colnames(qx_mat[,2:6]),z = qx_mat[,2:6], type = "surface") %>%
layout(
title = paste0('Morocco Qx - Male'),
scene = list( xaxis = list(title = "Year"),
yaxis = list(title = "Age"),
zaxis = list(title = "RR"))  )
f<- paste0('W:/399-External/_Erwan/Model/qx_morocco.html')
htmlwidgets::saveWidget(p, file= file.path(normalizePath(dirname(f)),basename(f)), title ='Morocco_Qx_Male',selfcontained = TRUE)
